Как я понял замыкания.  

Замыкания - это способности ф-ции запоминать ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ, в котором она была создана (т.е. хранить ссылку на это окружение).
Более подробно в видео:

![[ЗАМЫКАНИЯ В JS за 15 минут_ ОТ и ДО _ Что такое лексическое окружение и как связано с замыканием_ 720.mp4]]
[https://www.youtube.com/watch?v=mI6Jcfsgma4]()

Первое на что стоит обратить внимание в статье, так это на способ присвоения делегату ссылки на метод:  

```
var fn = Outer(); 
```

  
Тут видно, что делегату fn присваивается ссылка на **результат** выполнения функции Outer.  
Стоит помнить, что делегаты хранят ссылки на методы. Значит нам нужно, чтобы метод Outer возвращал в результате своего выполнения другой метод, иначе будет ошибка.  
Например:  

```
var fn = Outer(); int Outer(){int a=0;a++;return a;}delegate int TestDelegate()
```

  
Данный код не будет работать, ведь делегат fn ждет на вход метод, а получает на входе результат выполнения метода Outer, который возвращает **число**. Это выглядит так  

```
TestDelegate fn = return a // переменная типа int из метода Outer; 
```

  
Понимаю ,что пример дурацкий, но иначе не могу. Похожий код будет работать, если fn давать ссылку не на результат выполнения метода, а на сам метод:  

```
var fn = Outer; int Outer(){int a=0;a++;return a;}delegate int TestDelegate()
```

  
Тут ошибки не будет так как в fn мы записали ссылку на метод Outer. Но в таком случае замыкания не будет и сколько бы раз мы не пытались, но fn всегда будет возвращать 1.  
Замыкание происходит в тот момент, когда мы имеем функцию, которая возвращает другую функцию. Например:  

```
TestDel test=TestMethod();test(); //Вывод: 1test(); //Вывод: 2test(); //Вывод: 3TestDel TestMethod()    {    int a = 0;        void localFunc()     {        a++;        Console.WriteLine($"Вывод: {a}");    }    return localFunc;    }delegate void TestDel();
```

  
В данном случае мы имеем делегат, который получает ссылку на результат выполнения метода TestMethod:  

```
TestDel test=TestMethod();
```

  
В в свою очередь означает это:  

```
TestDel test=localFunc;
```

  
Обратите внимание, но тут localFunc используется как ссылка на сам метод, а не результат его исполнения.  
При этом, выполняя данный код:  

```
TestDel test=TestMethod();
```

  
Делегат test вместе с внутренним методом localFunc получает и всё окружение которое было "вокруг" локального метода.  
По этой причине, когда мы будет использовать делегат test() как метод, локальное окружение localFunc не будет перезаписываться, а продолжит храниться вместе с методом внутри делегата.  


Можно еще и так делать:  

```C#
int a = 10;
var sum = (int b) => (int c) => Console.WriteLine(a + b + c);
var del = sum(7);
del(5);/*22*/
del(10);/*27*/
del(15);/*32*/
```

**ЗАЧЕМ ЭТО НУЖНО?**

В том же LINQ мы используем замыкания, как будто так и должно быть, не задумываясь, как это называется:

```C#
int[] arr = {2, 4};
int multiplier = 10;

var newArr = arr.Select(num => num * multiplier).ToArray();
```

ИЛИ
```C#
int multiplier = 10;  
Func<int, int> function = num => num * multiplier;
```

Смысл в том, что наш лямбда-селектор запоминает переменную-множитель, а вызывается и использует ее уже где-то в другом месте - в реализации Select - вне области видимости переменной multiplier.
![[Замыкание(Closure)_BP2-2-1-10 .mp4]]