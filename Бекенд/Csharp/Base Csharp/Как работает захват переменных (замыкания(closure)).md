1) **Захват по значению (value capture)** - переменная копируется в область памяти, выделенную для лямбда выражения. Это происходит, когда переменная объявлена как **readonly** или  является литералом или локальной переменной, значения которых не изменяются после захвата..
2) **Захват по ссылке (reference capture)** - лямбда-выражение получает ссылку на оригинальную переменную в стеке вызовов метода. Это происходит для всех остальных переменных, которые не являются readonly или литералами или локальными переменными.

Пример:
```C#
for (int i = 0; i < 1000; i++)
{
    ThreadPool.QueueUserWorkItem(delegate
    {
        Console.WriteLine(i);
        Thread.Sleep(100);
    });
}
```
Здесь постоянно будет выводится число 1000.

Теперь давайте разберемся, почему выводится число 1000.

В цикле for переменная i является счетчиком, который увеличивается с каждой итерацией. Проблема заключается в том, что внутри делегата используется текущее значение переменной i, а не то значение, которое было на момент создания делегата.

Когда цикл завершается, переменная i имеет значение 1000 (точнее, 1000 - это значение, при котором условие i < 1000 становится ложным, и цикл прекращается). Теперь, когда потоки из пула начинают выполнять созданные задачи, все они используют последнее значение переменной i, которое равно 1000.

Таким образом, каждая задача выводит число 1000 в консоль, а затем приостанавливается на 100 миллисекунд. После выполнения всех задач программа завершается.

Чтобы исправить этот код и получить ожидаемый результат (вывод чисел от 0 до 999), необходимо захватить значение переменной i на каждой итерации цикла. Это можно сделать, объявив новую переменную внутри цикла и присвоив ей значение i. Затем в делегате нужно использовать эту новую переменную вместо i.

```C#
 for (int i = 0; i < 1000; i++)
 {
     int  local = i;
     ThreadPool.QueueUserWorkItem(delegate
     {
         Console.WriteLine(local);
         Thread.Sleep(100);
     });
 }
```