Сборщик мусора - код, который проверяет доступность объектов в памяти и освобождает память от недоступных.  При его выполнении все потоки программы будут остановлены. После очистки объектов произойдет дефрагментация памяти.

Small Objects Heap (SOH) < 85000 байт
Large Object Heap (LOH) >= 85000 байт (Им сразу устанавливается 2 поколение). Проверить поколение объекта **GC.GetGeneration(obj)**

Поколение 0: 256 Kb - 4 Mb
Поколение 1: 512 Kb - 4 Mb
Поколение 2: 2 Гб (x86), 8 TБ (x64)

Причины вызова сборщика:
1) Размер поколения достиг порогового значения (лимиты выше)
2) Вызван метод GC.Collect()
3) ОС послала уведомлении о низком уровне свободной памяти

Если после очистки первого поколения все еще требуется свободная память, сборщик переходит ко 2 поколению.

**Сборка мусора** – это низкоприоритетный процесс, который служит в качестве автоматического менеджера памяти, управляющего распределением и освобождением памяти для приложений. Каждый раз, когда создается новый объект, среда выполнения общего языка выделяет память для этого объекта из управляемой кучи. Пока в управляемой куче есть свободное пространство памяти, среда выполнения продолжает выделять место для новых объектов. Однако память не бесконечна, и как только приложение заполняет пространство, в дело вступает сборщик мусора (Garbage Collector), который освобождает часть памяти. Когда сборщик мусора выполняет очистку, он проверяет объекты в управляемой куче, которые больше не используются приложением, и выполняет необходимые операции. Сборщик мусора останавливает все запущенные потоки, находит все объекты в куче, к которым не обращается основная программа, и удаляет их. Затем он собирает все объекты, оставшиеся в куче, чтобы освободить место, и корректирует все указатели на эти объекты в стеке и в куче.

Там же можно увидеть, что существует 5 фаз: маркировки, планирования, обновления ссылок, компактинга (удаление с перемещением) и удаление без перемещений (перевести это дело сложно). Но формально это можно разделить на 3 этапа — маркировка, планирование, чистка.

На **этапе маркировки** выясняется, какие объекты не стоит собирать сборщику.  
На **этапе планирования** производятся расчет различных показателей текущего состояния памяти и сбор данных, необходимых на этапе чистки. Благодаря информации, полученной на этом этапе, выносится решение о необходимости компактинга (дефрагментации), там же просчитывается, на сколько необходимо двигать объекты и т.д.  
  
И на **этапе чистки** в зависимости от необходимости компактинга может производится обновление ссылок и компактинг или удаление без перемещений.

#Csharp #Garbage_Collector #Очистка_мусора