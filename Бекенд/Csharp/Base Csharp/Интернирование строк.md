Интернирование строк - это механизм, при котором одинаковые литералы представляют собой один объект в памяти.
Если не вникать глубоко в подробности данного механизма, то смысл интернирования строк заключается в следующем: в рамках процесса (именно процесса , а не домена приложения) существует внутренняя хеш-таблица, ключами которой являются строки, а значениями - ссылки на них.
Во время JIT-компиляции литеральные строки последовательно заносятся в хеш-таблицу (каждая строка встречается в таблице только один раз). На этапе выполнения ссылки на литеральные строки присваиваются из этой таблицы.
Можно поместить строку в эту таблицу во время выполнения с помощью метода String.Intern. Также можно проверять содержится ли строка в этой таблице с помощью метода String.IsInterned.

```C#
var s1 = "habrahabr";
var s2 = "habrahabr";
var s3 = "habra" + "habr";

Console.WriteLine(object.ReferenceEquals(s1, s2));//true
Console.WriteLine(object.ReferenceEquals(s1, s3));//true
```

Важно отметить, что интернируются по умолчанию только строковые литералы. Поскольку для реализации интернирования используется внутренняя хеш-таблица, то во время JIT компиляции происходит поиск по ней, что занимает время, поэтому если бы интернировались все строки, то это свело бы на нет всю оптимизацию. Во время компиляции в IL код, компилятор конкатенирует все литеральные строки, так как нет в необходимости содержать их по частям, поэтому 2 — ое равенство возвращает true. Так вот, в чем заключается казус. Рассмотрим следующий код:  

```C#
var s = "Strings are immutable";
int length = s.Length;
unsafe
 {
  fixed (char* c = s)
   {
    for (int i = 0; i < length / 2; i++)
     {
      var temp = c[i];
      c[i] = c[length - i - 1];
      c[length - i - 1] = temp;
     }
   }
 }
Console.WriteLine("Strings are immutable");
```

Кажется, что здесь все очевидно и, что такой код должен распечатать **Strings are immutable**. Однако, нет! Код напечатает **elbatummi era sgnirtS**. Дело именно в интернировании, изменяя строку s, мы меняем ее содержимое, а так как она является литералом, то интернируется и представляется одним экземпляром строки.  
  
От интернирования строк можно отказаться, если применить специальный атрибут **CompilationRelaxationsAttribute** к сборке. Атрибут **CompilationRelaxationsAttribute** контролирует точность кода, создаваемого JIT-компилятором среды CLR. Конструктор данного атрибута принимает перечисление **CompilationRelaxations** в состав, которого на текущий момент входит только **CompilationRelaxations.NoStringInterning** — что помечает сборку как не требующую интернирования.  
  
Кстати, этот атрибут не обрабатывается в .NET Framework версии 1.0., поэтому отключить интернирование по умолчанию не было возможным. Сборка mscorlib, начиная со второй версии, помечена этим атрибутом.  
  
Получается, что строки в .NET все-таки можно изменить, если очень захотеть, применяя unsafe код.

#### Особенности производительности
  
У интернирования есть отрицательный побочный эффект. Дело в том, что ссылка на интернированный объект String, которую хранит CLR, может сохраняться и после завершения работы приложения и даже домена приложения. Поэтому большие литеральные строки использовать не стоит или же, если это необходимо стоит отключить интернирование, применив атрибут CompilationRelaxations к сборке.