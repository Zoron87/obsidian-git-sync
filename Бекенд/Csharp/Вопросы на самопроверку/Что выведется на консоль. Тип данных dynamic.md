```C#
byte num = 100;
dynamic val = num;
Console.WriteLine(val.GetType());

val += 200;
Console.WriteLine(val.GetType());
```

Ответом будет:
```C#
System.Byte
System.Int32
```

Тип dynamic является статическим типом, но объект типа dynamic проходит статический тип проверка. В большинстве случаев он работает как тип object.

В версии .NET 4.0 язык C# стал поддерживать ключевое слово dynamic. На самом высоком уровне dynamic можно рассматривать как специализированную форму System.Object, в том смысле, что типу данных dynamic может быть присвоено любое значение.
Данный тип данных бывает полезен при рефлексии. 

А также в первую очередь, нужен там, где без него раньше не обойтись, а именно для обхода компиляции внешних неизвестных на момент компиляции типов.
Пример - для взаимодействия с COM, использовались .Interop assembiles, генерируемые для приложений COM, что снова приводило к проблеме Dll Hell, так как генерация сборок требовала соотвествия поставляемой с приложением версии .Interop сборки и установленного на компьютере COM приложения, даже если API этих двух приложений были бинарно совместимыми.
Для обхода компилятора, построенного на строгой типизации языка, без использования сильно типизированных сборок-оберток над COM, требовался тип, который бы собирался компилятором как произвольный, или динамический, тип, который и получил название dynamic.

**Отличие от var**

Ключевое слово var позволяет объявлять локальную переменную таким образом, что ее действительный тип данных определяется начальным присваиванием (это называется неявной типизацией). Как только начальное присваивание выполнено, вы получаете строго типизированную переменную, и любая попытка присвоить ей несовместимое значение приведет к ошибке компиляции.