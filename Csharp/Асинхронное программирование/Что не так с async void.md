- Невозможно использовать с await (т.е. ожидать результата)
- Невозможно определить, когда выполнение завершится (если только не использовать callback)
- Вызывающий код не может перехватить возникающие исключения
Вывод: Везде, где доступно следует использовать async-Task вместо async void!

Подробнее в статье "Why is 'async void' Wrong and What To Do Instead" от fornever.

# **Реальные примеры использования**

1. **Параллельная обработка:** вы можете использовать Task.WhenAll для ожидания завершения нескольких задач при выполнении параллельной обработки. Например, если вы загружаете файлы из нескольких источников, вы можете использовать Task.WhenAll, чтобы эффективно дождаться завершения всех загрузок, прежде чем продолжить дальнейшую обработку.
2. **Веб-скрапинг:** при одновременном сборе данных с нескольких веб-страниц вы можете использовать Task.WhenAll для асинхронного ожидания завершения всех задач очистки.
3. **Обработка данных.** Если вы обрабатываете большие объемы данных и хотите разделить рабочую нагрузку между несколькими задачами, вы можете использовать Task.WhenAll для эффективного управления выполнением всех задач и перехода к дальнейшему анализу после выполнения всех задач.
4. **Фоновые задачи.** В веб-приложении вы можете использовать Task.WhenAll для управления несколькими фоновыми задачами и обеспечения их успешного завершения перед выполнением дальнейшей обработки.