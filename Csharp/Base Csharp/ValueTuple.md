
`ValueTuple` — это **значимый** тип данных, а конкретнее **структура**, предоставляющая возможность хранить и передавать набор значений. Это легковесная альтернатива классу `Tuple`, представленная в C# 7.0.

`ValueTuple` используют синтаксис, который позволяет более компактно и удобно описывать, возвращать и обрабатывать данных без необходимости определять отдельные классы для этих целей.

Основные отличия `ValueTuple` от `Tuple`

1. `ValueTuple` является **значимым** типом (структурой). `Tuple` же является **ссылочным** типом. Это означает, что данные `ValueTuple` хранятся в **стеке**, что может быть более эффективным с точки зрения производительности и управления памятью для **небольших и простых** данных. 
    
2. `ValueTuple` является **изменяемым**, в то время как `Tuple` — **неизменяемый** тип данных
    

### Объявление кортежа (`ValueTuple`)

Объявить `ValueTuple` можно несколькими способами:

```cs
// Явное указание типов
ValueTuple<int, int> valueTuple = new ValueTuple<int, int>(1, 2); 
(int, int) tuple2 = (1, 2); // Более короткая запись

// Неявное указание типов
var tuple3 = (1, 2);
```

Во всех трех случаях тип данных будет `ValueTuple`

### Именование элементов `ValueTuple`

Мы можем дать названия элементам `ValueTuple`

```cs
var tuple = (min: 5, max: 10);
Console.WriteLine(tuple.min); // 5
Console.WriteLine(tuple.max); // 10
Console.WriteLine(tuple.Item1); // 5
```

Теперь для обращения к полям кортежа можно использовать как их имена, так и названия по умолчанию `Item1` и `Item2`.  
**Оба** варианта будут работать.

Теперь, когда мы познакомились с новым типом данных, мы можем **упростить** решение нашей проблемы из прошлой лекции

```cs
public static Tuple<double, double> GetStudentsPoints(List<Student> students)
{
    double min = 100;
    double max = 0;
    foreach (Student stud in students)
    {
         if (stud.AverageGrade > max) max = stud.AverageGrade;
         if (stud.AverageGrade < min) min = stud.AverageGrade;
    }
    // Возвращаем кортеж из двух значений max и min
    return new Tuple<double, double>(max, min);
}
```

Так как данные **простые и небольшие** (два числа), то давайте заменим обычный кортеж на тип данных `ValueTuple` и для удобства установим имена элементам.

```cs
public static (double min, double max) GetStudentsPoints(List<Student> students)
{
	double min = 100;
	double max = 0;
	foreach (Student stud in students)
	{
		if (stud.AverageGrade > max) max = stud.AverageGrade;
		if (stud.AverageGrade < min) min = stud.AverageGrade;
	}
	// Возвращаем ValueTuple из двух значений max и min
	return (max, min);
}
```

 Здесь мы заменили возвращаемый тип данных на `ValueTuple`, а также дали названия элементам для читаемости.

### **Присваивание кортежей**

В кортежах есть возможность присваивания, для этого оба кортежа должны иметь **одинаковое количество элементов**. Типы соответствующих значений должны совпадать или иметь возможность неявного приведения друг к другу. Значения присваиваются в порядке их расположения. При присвоении названия элементов не учитываются.

Пример:

```cs
(int, int) tuple1 = (10, 15);
(double, double) tuple2 = (1.5, 1.6);

tuple2 = tuple1; // Неявное приведение int к double
Console.WriteLine(tuple2); // (10, 15)
```

### Деконструкция кортежей 

**Деконструкция кортежа** — это операция присваивания элементов кортежа в отдельные переменные.

Рассмотрим на примере функции `GetStudentsPoints`:

```cs
var tuple = GetStudentsPoints(students);
(double max, double min) = tuple;
Console.WriteLine(min + " " + max); // 1 3
```

### Переопределенные методы `ValueTuple`

1. `Equals(object obj)` — сопоставляет кортежу какой-либо объект и возвращает `true`, если:

- Это объект такого же типа
- Все его элементы имеют те же типы, что у данного кортежа.
    
- Все его элементы идентичны элементам текущего кортежа. 
    

Также вместо `Equals`, можно использовать `==`,  работать все будет точно так же, например:

```cs
var t1 = Tuple.Create<int, int>(0, 0);
var t2 = Tuple.Create<int, int>(1, 2);

Console.WriteLine(t1 == t2); // False
```

2. `ToString()` — возвращает строку,  вида `(Item1, Item2, ... )`

3. `Create()`  — создает новый объект кортежа. Можно использовать для создания экземпляра кортежа без необходимости явно указывать типы элементов.

4. `CompareTo()` — cравнивает текущий экземпляр `ValueTuple` с указанным экземпляром `ValueTuple`

5. `ToTuple()` — преобразует кортеж значений `ValueTuple` в кортеж `Tuple`.

6. `ToValueTuple()` — преобразует кортеж `Tuple` в кортеж значений `ValueTuple`.