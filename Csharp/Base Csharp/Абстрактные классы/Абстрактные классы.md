Нельзя создавать конструкторы абстрактных классов для создания экземпляра класса, только через реализацию в классах-наследниках. Тем не менее такой класс может определять конструкторы, например:
```C#
abstract class Transport
{
    public string Name { get; }
    // конструктор абстрактного класса Transport
    public Transport(string name)
    {
        Name = name;
    }
    public void Move() =>Console.WriteLine($"{Name} движется");
}
// класс корабля
class Ship : Transport 
{
    // вызываем конструктор базового класса
    public Ship(string name) : base(name) { }
}
// класс самолета
class Aircraft : Transport
{
    public Aircraft(string name) : base(name) { }
}
```
Кроме обычных свойств и методов абстрактный класс может иметь абстрактные члены классов, которые определяются с помощью ключевого слова abstract и не имеют никакого функционала. В частности, абстрактными могут быть:

- Методы
- Свойства
- Индексаторы
- События

Абстрактные члены классов не должны иметь модификатор private. При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе. При переопределении в производном классе такой метод или свойство также объявляются с модификатором override (как и при обычном переопределении виртуальных методов и свойств). Также следует учесть, что если класс имеет хотя бы один абстрактный метод (или абстрактные свойство, индексатор, событие), то этот класс должен быть определен как абстрактный. 
Абстрактные члены также, как и виртуальные, являются частью полиморфного интерфейса. Но если в случае с виртуальными методами мы говорим, что класс-наследник наследует реализацию, то в случае с абстрактными методами наследуется интерфейс, представленный этими абстрактными методами.

Пометка класса как "abstract" говорит ему, что код этого класса используется для создания других классов и **ни при каких условиях не будет исполняться самостоятельно**. Поэтому он не попадет в окончательный код. А попытка создать его экземпляр приведет к ошибке, потому что в **коде его не будет**, а не потому что в учебнике это запрещено.
Т.е. мы трактуем его как абстрактный класс и все такое, а для компилятора это кусок кода, который потом не пригодится. Его надо использовать для наследования при сборке кода, но не надо включать в код. В смысле в исполняемый код, а не в то, что мы видим как *.exe. И для того, чтобы мы поняли друг-друга (мы и компилятор) пишем "abstract". Именно поэтому очень часто удаление "abstract" не приводит к видимым результатам. Код утяжеляется, но продолжает нормально работать.  
Получается, что "abstract" - это связка между теорией и практикой. Признак хорошего стиля, так сказать. Можно обойтись без этого и все будет работать, но это уже будет не лучший продукт.

#### Абстрактные свойства

Следует отметить использование абстрактных свойств. Их определение похоже на определение автосвойств. Например:
```C#
abstract class Transport
{
    // абстрактное свойство для хранения скорости
    public abstract int Speed { get; set; } 
}
// класс корабля
class Ship: Transport
{
    int speed;
    public override int Speed 
    { 
        get => speed; 
        set => speed = value; 
    }
}
 
class Aircraft : Transport
{
    public override int Speed { get; set; }
}
```
В классе Transport определено абстрактное свойство Speed, которое должно хранить скорость транспортного средства. Оно похоже на автосвойство, но это не автосвойство. Так как данное свойство не должно иметь реализацию, то оно имеет только пустые блоки get и set. В производных классах мы можем переопределить это свойство, сделав его полноценным свойством (как в классе Ship), либо же сделав его автоматическим (как в классе Aircraft).

#### Отказ от реализации абстрактных членов

Производный класс обязан реализовать все абстрактные члены базового класса. Однако мы можем отказаться от реализации, но в этом случае производный класс также должен быть определен как абстрактный:
```C#
Transport tesla = new Auto();
tesla.Move();           // легковая машина едет
abstract class Transport
{
    public abstract void Move();
}
// класс машины
abstract class Car : Transport{}
 
class Auto: Car
{
    public override void Move()
    {
        Console.WriteLine("легковая машина едет");
    }
}
```
В данном случае класс Car не реализует абстрактный метод Move базового класса Transport и поэтому также определен как абстрактный. Однако любые неабстрактные классы, производные от Car, все равно должны реализовать все унаследованные абстрактные методы и свойства.

#Абстрактные_классы 