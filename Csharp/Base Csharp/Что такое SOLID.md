Solid - принцип разработки программного обеспечения, соблюдая которые вы получите хороший масштабируемый код, который будет легко поддерживать в рабочем состоянии.

SOLID - это аббревиатуры, обозначающая первые 5 принципов объектно-ориентированного программирования, сформулированные Робертом С. Мартином (также известным как [дядя Боб]([https://en.wikipedia.org/wiki/Robert_C._Martin|Дядя]) ). 

**S  (single responsibility principle - принцип единственной ответственности)** - Каждый класс должен иметь только одну зону ответственности (чистые методы и ф-ции).
![[Solid-S.png]]

---

**O  (open cloded priniciple - принцип открытости закрытости)** - Класс должен закрыт для изменения, но открыт для расширения (н-р, через перегрузки)
![[Solid-O.png]]
Когда вы меняете текущее поведение класса, эти изменения сказываются на всех системах, работающих с данным классом. Если хотите, чтобы класс выполнял больше операций, то идеальный вариант – не заменять старые на новые, а добавлять новые к уже существующим.

---

**L - (Liskov substitution principle - принцип подстановки Барбары Лисков)** - Должна быть возможность подставить вместо базового (родительского) класса подставить любой его подтип (класс-наследник), при этом его работа не должна измениться.
![[Solid-L 1.png]]
> _Если П является подтипом Т, то любые объекты типа Т, присутствующие в программе, могут заменяться объектами типа П без негативных последствий для функциональности программы._

В случаях, когда класс-потомок не способен выполнять те же действия, что и класс-родитель, возникает риск появления ошибок.  
  
Если у вас имеется класс и вы создаете на его базе другой класс, исходный класс становится родителем, а новый – его потомком. Класс-потомок должен производить такие же операции, как и класс-родитель. Это называется наследственностью.  
  
Необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. Или же результат может отличаться, но при этом относиться к тому же типу. На картинке это показано так: класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино (разновидность кофе), но неприемлемо подавать воду.  
  
Если класс-потомок не удовлетворяет этим требованиям, значит, он слишком сильно отличается от родителя и нарушает принцип.

---

**I - (interface segregation principle - принцип разделения интерфейсов)** - Данный принцип говорит о том, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.
![[Solid-I.png]]
>_Не следует ставить клиент в зависимость от методов, которые он не использует_

Когда классу приходится производить действия, не несущие никакой реальной пользы, это выливается в пустую трату ресурса, а в случае, если класс выполнять эти действия не способен, ведёт к возникновению багов.  
  
Класс должен производить только те операции, которые необходимы для осуществления его функций. Все другие действия следует либо удалить совсем, либо переместить, если есть вероятность, что они понадобятся другому классу в будущем.

---

**D - (dependency inversion principle - принцип инверсии зависимостей)** - Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракции. (Этот принцип служит для того, чтобы устранить зависимость классов верхнего уровня от классов нижнего уровня за счёт введения интерфейсов.)

Объясним термины, которые здесь применяются, простыми словами.  
  
**Модули (или классы) верхнего уровня** = классы, которые выполняют операцию при помощи инструмента  
**Модули (или классы) нижнего уровня** = инструменты, которые нужны для выполнения операций  
**Абстракции** – представляют интерфейс, соединяющий два класса  
**Детали** = специфические характеристики работы инструмента  
  
Согласно данному принципу, класс не должен соединяться с инструментом, который применяет для выполнения операции. Вместо этого он должен быть соединён с интерфейсом, который поможет установить связь между инструментом и классом.

Кроме того, принцип гласит, что ни интерфейс, ни класс, не обязаны вникать в специфику работы инструмента. Напротив, это инструмент должен подходить под требования интерфейса.

![[Solid-D.png]]

---
---

Объясняем на примере армии и военно-морского флота!

Для начала договоримся, что есть базовый тип военного человека - солдат. А есть рядовой Иванов, рядовой Петров, ефрейтор Сидоров, и майор Фролов - они тоже солдаты, но имеют индивидуальные отличия. Ещё есть военные специальности, например, танкист или разведчик. Это тоже солдаты, но танкистом может быть как рядовой, так и майор.  

**Принцип единственной ответственности**

_Правильный солдат должен уметь родину защищать, и более ничего. Правильный танкист - управлять танком, и более ничего. Ну и т.д._

Если нарушить этот принцип и нагрузить солдата дополнительной ответственностью (например, покраска травы), то это будет не солдат, а вооружённый маляр-садовод. Отсюда в армии разброд и шатание.

Но как научить конкретного рядового Иванова красить траву? Всё просто: когда надо родину защищать, будем считать Иванова солдатом; если надо красить траву - считаем его маляром.

И, соответственно, обращаться будем так: "Рядовой Иванов, как солдату приказываю защищать родину". Либо "Рядовой Иванов, ты маляр, крась траву". И родина спит спокойно, и трава зеленеет даже зимой.

**Принцип открытости-закрытости**

_Хочешь переучить танкиста на разведчика? Не порть танкиста, лучше сделай нового солдата-разведчика._

Итак, у нас есть солдаты: пулеметчик и водитель танка. Хорошо бы определить, как они идут в атаку, например.
  
Неправильным решением будет завести специально обученного майора, которому мы скажем: "веди всех в атаку", и он будет командовать пулеметчику: "стреляй из пулемета", а водителю танка: "куды прёшь, враг в другой стороне!". А ну как нам понадобится лётчик? Придётся тогда майора учить отдельной команде "от винта!", а он уже устал.

Правильно будет обучить каждого солдата по-своему исполнять команду "в атаку", а майору дать громкоговоритель и научить команде "солдаты, в атаку". Тогда все, кто услышит эту команду, пойдут в атаку как умеют.

**Принцип подстановки Барбары Лисков**

_Любой, кто является солдатом, должен уметь вести себя как солдат, неважно рядовой он или танкист._

Это значит, что товарищ генерал, для которого все солдаты на одно лицо, всё равно сможет командовать вообще любым солдатом. Если бы это было не так, то товарищ генерал не смог бы воевать по карте, ему пришлось бы подходить к каждому и объяснять, что от него требуется.

**Принцип разделения интерфейса**

_Не надо учить солдата слишком разнообразным командам, иначе найдётся майор, который не будет знать все команды, и не сможет управлять солдатом._

То есть, пулеметчик, танкист и повар знают очень специфические команды (стреляй, газуй, вари), которые не обязан знать базовый солдат. Но чтобы повар смог приготовить обед, заведём начальника столовой, которому можно сказать "защищай родину", а тот транслирует приказ повару: "вари обед". И все.

**Принцип инверсии зависимостей**

_Базовый солдат не должен знать про рядовых или разведчиков, но и рядовой и разведчик должны знать, что они солдаты. Причём рядовой-разведчик и майор-разведчик должны знать, что они разведчики и солдаты, а базовый разведчик знает что он солдат и не более того._

Другими словами, если надо отправить кого-то в разведку, то правильно взять любого разведчика и отправить его в разведку. Неправильно требовать для этого именно майора-разведчика, потому что кого дадут, того дадут, и нечего тут. Тем более, знаки различия снимут во избежание.

Кстати, сохраняется и принцип подстановки Барбары Лисков. Ведь все разведчики, независимо от звания, ведут себя как разведчики.

#Csharp #ООП 