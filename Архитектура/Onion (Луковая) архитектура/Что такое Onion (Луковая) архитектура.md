https://code-maze.com/onion-architecture-in-aspnetcore/

Архитектура Onion является формой многоуровневой архитектуры, и мы можем визуализировать эти слои как концентрические круги. Отсюда и название — архитектура Onion. Архитектура Onion была впервые представлена ​​Джеффри Палермо для преодоления проблем традиционного подхода к архитектуре с N-слоями.

Существует несколько способов разделения луковицы, но мы выберем следующий подход, при котором мы разделим архитектуру на 4 слоя:

- Уровень домена
- Уровень обслуживания
- Уровень инфраструктуры
- Уровень представления

Концептуально можно считать, что уровни инфраструктуры и представления находятся на одном уровне иерархии.

Теперь давайте продолжим и рассмотрим каждый слой более подробно, чтобы понять, зачем мы его вводим и что мы собираемся создать внутри этого слоя:
![[Pasted image 20241230231341.png]]

## Преимущества луковой архитектуры

Давайте рассмотрим, в чем заключаются преимущества архитектуры Onion и почему нам стоит внедрить ее в наши проекты.

Все слои взаимодействуют друг с другом строго через интерфейсы, определенные в слоях ниже. Поток зависимостей направлен к ядру Onion. Мы объясним, почему это важно, в следующем разделе.

Использование инверсии зависимостей на протяжении всего проекта, в зависимости от абстракций (интерфейсов), а не реализаций, позволяет нам прозрачно переключать реализацию во время выполнения. Мы зависим от абстракций во время компиляции, что дает нам строгие контракты для работы, и нам предоставляется реализация во время выполнения.

Тестируемость очень высока с архитектурой Onion, потому что все зависит от абстракций. Абстракции можно легко имитировать с помощью библиотеки имитации, такой как [Moq](https://github.com/moq/moq4) . Чтобы узнать больше о модульном тестировании ваших проектов в ASP.NET Core, ознакомьтесь с этой статьей [Тестирование контроллеров MVC в ASP.NET Core](https://code-maze.com/testing-mvc-controllers-asp-net-core/) .

Мы можем писать бизнес-логику, не беспокоясь о деталях реализации. Если нам что-то нужно от внешней системы или сервиса, мы можем просто создать для него интерфейс и использовать его. Нам не нужно беспокоиться о том, как это будет реализовано. Более высокие уровни Onion позаботятся о реализации этого интерфейса прозрачно.

## Поток Зависимостей

Основная идея архитектуры Onion — поток зависимостей, или, скорее, то, как слои взаимодействуют друг с другом. Чем глубже слой находится внутри Onion, тем меньше у него зависимостей.  

Уровень домена не имеет прямых зависимостей от внешних уровней. Он изолирован, в некотором смысле, от внешнего мира. Внешним уровням разрешено ссылаться на уровни, которые находятся непосредственно под ними в иерархии.

Мы можем сделать вывод, что все зависимости в архитектуре Onion направлены внутрь. Но мы должны спросить себя, почему это важно?

Поток зависимостей диктует, что может делать определенный слой в архитектуре Onion. Поскольку он зависит от слоев, расположенных ниже в иерархии, он может вызывать только те методы, которые предоставляются нижними слоями.

Мы можем использовать нижние слои архитектуры Onion для определения контрактов или интерфейсов . Внешние слои архитектуры реализуют эти интерфейсы. Это означает, что на уровне домена мы не беспокоимся о деталях инфраструктуры, таких как база данных или внешние службы.

Используя этот подход, мы можем инкапсулировать всю богатую бизнес-логику в уровнях Домена и Сервиса, не зная никаких деталей реализации. В уровне Сервиса мы будем зависеть только от интерфейсов, которые определены уровнем ниже, который является уровнем Домена.

#Onion_architecture 
#Csharp 
#Луковая_Архитектура
