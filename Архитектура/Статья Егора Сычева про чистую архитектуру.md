Архитектура которую я использую в своих проектах

В этом посте я хочу поделиться архитектурой приложений, которую я использую в реальных проектах и которая хорошо себя зарекомендовала. 

При проектировании архитектуры приложения я поставил для себя следующие требования:

— Приложение должно легко покрываться тестами
— Приложение должно легко обновляться, переходить на новые версии .Net
— Код должен быть простым, так его становится легче поддерживать, новые разработчики быстрее втягиваются в процесс
— Легко можем заменить поставщика данных, например с БД на внешний сервис, такое часто происходит в крупных компаниях с множеством команд разработки
— Не использовать библиотеки которые влияют на архитектуру Revo, Marten, MediatR и т. д.

На практике я встречал много проектов которые не соответствовали этим требованиям. Поддержка, написание новых фич было достаточно затруднительно, никаких тестов соответственно тоже не было.

Данная архитектура является чистой, используется всего три слоя: Api, Core, Infrastructure, однако не стоит путать с трехзвенной архитектурой, в нашем случае используется принцип инверсии зависимостей. Так например, бизнес-слой (Core) не использует напрямую слой Infrastructure и не ссылается на него как проект. 

Пример структуры приложения:
Api.csproj
├── Controllers
│   └── ProductController.cs

Core.csproj
├── RepositoriesContracts
│   └── IProductRepository.cs
├── UseCases
│   └── GetProduct
│       ├── GetProductUseCase.cs
│       └── IGetProductUseCase.cs

Infrastructure.csproj
├── Repositories
│   └── ProductRepository.cs

Использование только трех слоев позволяет избежать путаницы и возможной протечки абстракции в перспективе. Вся бизнес-логика расположена в слое Core. 

Как мы помним, основное требование было возможность замены поставщика данных без внесения изменений в бизнес-слой. Это действительно важное требование в наших приложениях, так как источники данных часто меняются. Например, ранее отправляли данные по REST сейчас другая команда просит отправлять эти данные в Kafka или раннее данные получали из БД затем часть этого функционала забрала себе другая команда и выставила REST. 

Чтобы выполнить это требование бизнес-логика в слое Core должна работать с данными только через интерфейсы, в моем случае они имеют суффикс Repository тем самым абстрагируясь от типа источника данных. 

Далее для выполнения этого требования модель данных, которую мы получили от источники должна мапится в другую модель - возвращаемый результат  IProductRepository. Маппинг должен происходить на уровне Infrastructure, помним что Core не должен иметь зависимость от других проектов, но Infrastructure имеет зависимость от Core т.к. реализует интерфейс IProductRepository.

Такая абстракция также позволяет нам легко писать юнит-тесты, а с началом использования Copilot в нашей команде с этим отлично справляется Github Copilot.

Я использую эту архитектуру на протяжении 3-х лет и она отлично себя зарекомендовала, мы начали применять ее для других проектов в команде. 
За это время действительно несколько раз менялись источники данных и это происходило без серьезных изменений в коде проекта. Благодаря простоте архитектуры Copilot отлично генерирует юнит-тесты, которые, в большинстве случаев запускаются с первого раза.

Пост на LinkedIn (https://www.linkedin.com/feed/update/urn:li:activity:7326131257191415808/), Medium (https://medium.com/@yegor-sychev/architecture-i-use-in-my-projects-60ab8a1b3c45)