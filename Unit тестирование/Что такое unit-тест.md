Unit-тест - быстрая изолированная проверка наименьшего возможного логически смыслового блока программного кода.

> **Модульное тестирование**, или **юнит-тестирование** (англ. unit testing) — процесс в программировании, позволяющий проверить на корректность отдельные модули исходного кода программы.  
>   
> Идея состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок.  

  
  
![](https://habrastorage.org/r/w1560/storage2/ec3/825/c7f/ec3825c7f0710f9fed6814c89b794ded.jpg)  
  
Таким образом, юнит-тестирование – это первый бастион на борьбе с багами. За ним еще интеграционное, приемочное и, наконец, ручное тестирование, в том числе «свободный поиск».

Для того чтобы темная сторона кода не взяла верх, нужно придерживаться **следующих основных правил**.  
Ваши тесты должны:  

- Быть достоверными
- Не зависеть от окружения, на котором они выполняются
- Легко поддерживаться
- Легко читаться и быть простыми для понимания (даже новый разработчик должен понять **что именно** тестируется)
- Соблюдать единую конвенцию именования
- Запускаться регулярно в автоматическом режиме

### Fakes: stubs & mocks

Мы переписали класс и теперь можем подсунуть контроллеру другие реализации зависимостей, которые не станут лезть в базу, смотреть конфиги и т.д. Словом, будут делать только то, что от них требуется. Разделяем и властвуем. Настоящие реализации мы должны протестировать отдельно в своих собственных тестовых классах. Сейчас мы тестируем только контроллер.

**Выделяют два типа подделок: стабы (stubs) и моки (mock).**  
Часто эти понятия путают. Разница в том, что стаб ничего не проверяет, а лишь имитирует заданное состояние. А мок – это объект, у которого есть ожидания. Например, что данный метод класса должен быть вызван определенное число раз. Иными словами, ваш тест никогда не сломается из-за «стаба», а вот из-за мока может.

## Тестовые двойники

Помощниками в тестировании выступают «тестовые двойники» (test doubles). Их выделяют 5 видов.
  
![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/2ad/927/119/2ad9271190b73e5b9d712ba007421ee8.png)

**Пустышка (Dummy)**. Такой двойник не содержит поведения и используется в качестве заполнителя параметров. Никогда реально не вызывается.

**Подделка (Fake)**. Это реально написанная реализация, которая имеет более простую логику, чем реальный аналог.

Есть ещё три вида похожих между собой тестовых двойников. Но есть и различия.

**Заглушка (Stub)** - имеет заранее подготовленные ответы на вызовы методов. Практически не имеет логики.

**Шпион (Spy)**. Более сложная система. Это гибрид реального объекта и мока. Он имеет поведение реального объекта, но может записывать определенную информацию о вызове его методов. Также можно переопределить поведение некоторых методов.

**Мок (Mock)**. Самый сложный из тестовых двойников, но дающий наибольший контроль. Может иметь сложную логику ответов, зависящих от параметров вызовов, их количества, генерировать исключения при вызове методов с неопределенным поведением и имеет другой, полезный для тестирования функционал.

Все тестовые двойники, за исключением fake, в основном создаются с помощью фреймворков, с которыми мы часто работаем. Для Java это Mockito, для Kotlin – MockK, для других языков такие фреймворки тоже есть.